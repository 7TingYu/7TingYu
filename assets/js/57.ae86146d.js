(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{649:function(v,_,e){"use strict";e.r(_);var t=e(23),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"_09-说说你对虚拟-dom-的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_09-说说你对虚拟-dom-的理解"}},[v._v("#")]),v._v(" 09 - 说说你对虚拟 DOM 的理解？")]),v._v(" "),e("p",[e("strong",[v._v("分析")])]),v._v(" "),e("p",[v._v("现有框架几乎都引入了虚拟 DOM 来对真实 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM，那么为\n什么需要引入虚拟 DOM 呢？围绕这个疑问来解答即可！")]),v._v(" "),e("p",[e("strong",[v._v("思路")])]),v._v(" "),e("ol",[e("li",[v._v("vdom是什么")]),v._v(" "),e("li",[v._v("引入vdom的好处")]),v._v(" "),e("li",[v._v("vdom如何生成，又如何成为dom")]),v._v(" "),e("li",[v._v("在后续的diff中的作用")])]),v._v(" "),e("p",[e("strong",[v._v("回答范例")])]),v._v(" "),e("ol",[e("li",[v._v("虚拟dom顾名思义就是虚拟的dom对象，它本身就是一个  JavaScript  对象，只不过它是通过不同的属性去\n描述一个视图结构。")]),v._v(" "),e("li",[v._v("通过引入vdom我们可以获得如下好处：")])]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("将真实元素节点抽象成 VNode，有效减少直接操作 dom 次数，从而提高程序性能")]),v._v(" "),e("ul",[e("li",[v._v("直接操作 dom 是有限制的，比如：diff、clone 等操作，一个真实元素上有许多的内容，如果直接对其\n进行 diff 操作，会去额外 diff 一些没有必要的内容；同样的，如果需要进行 clone 那么需要将其全部内\n容进行复制，这也是没必要的。但是，如果将这些操作转移到 JavaScript 对象上，那么就会变得简单\n了。")]),v._v(" "),e("li",[v._v("操作 dom 是比较昂贵的操作，频繁的dom操作容易引起⻚面的重绘和回流，但是通过抽象 VNode 进行\n中间处理，可以有效减少直接操作dom的次数，从而减少⻚面重绘和回流。")])])]),v._v(" "),e("li",[e("strong",[v._v("方便实现跨平台")]),v._v(" "),e("ul",[e("li",[v._v("同一 VNode 节点可以渲染成不同平台上的对应的内容，比如：渲染在浏览器是 dom 元素节点，渲染在\nNative( iOS、Android) 变为对应的控件、可以实现 SSR 、渲染到 WebGL 中等等")]),v._v(" "),e("li",[v._v("Vue3 中允许开发者基于 VNode 实现自定义渲染器（renderer），以便于针对不同平台进行渲染。")])])])]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[v._v("vdom如何生成？在vue中我们常常会为组件编写模板 - template， 这个模板会被编译器 - compiler编译为渲\n染函数，在接下来的挂载（mount）过程中会调用render函数，返回的对象就是虚拟dom。但它们还不是真\n正的dom，所以会在后续的patch过程中进一步转化为dom。")]),v._v(" "),e("li",[v._v("挂载过程结束后，vue程序进入更新流程。如果某些响应式数据发生变化，将会引起组件重新render，此时就\n会生成新的vdom，和上一次的渲染结果diff就能得到变化的地方，从而转换为最小量的dom操作，高效更新\n视图。")])]),v._v(" "),e("p",[e("strong",[v._v("知其所以然")])]),v._v(" "),e("p",[v._v("vnode定义：")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/vnode.ts#L127-L128")]),v._v(" "),e("p",[v._v("创建vnode：")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("createElementBlock:")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/vnode.ts#L291-L292")])]),v._v(" "),e("li",[e("p",[v._v("createVnode:")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/vnode.ts#L486-L487")])]),v._v(" "),e("li",[e("p",[v._v("首次调用时刻：")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/apiCreateApp.ts#L283-L284")])])]),v._v(" "),e("p",[v._v("mount:")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/renderer.ts#L1171-L1172")]),v._v(" "),e("h2",{attrs:{id:"_10-你了解diff算法吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-你了解diff算法吗"}},[v._v("#")]),v._v(" 10 - 你了解diff算法吗？")]),v._v(" "),e("p",[e("strong",[v._v("分析")])]),v._v(" "),e("p",[v._v("必问题目，涉及vue更新原理，比较考查理解深度。")]),v._v(" "),e("p",[e("strong",[v._v("思路")])]),v._v(" "),e("ol",[e("li",[v._v("diff算法是干什么的")]),v._v(" "),e("li",[v._v("它的必要性")]),v._v(" "),e("li",[v._v("它何时执行")]),v._v(" "),e("li",[v._v("具体执行方式")]),v._v(" "),e("li",[v._v("拔高：说一下vue3中的优化")])]),v._v(" "),e("p",[e("strong",[v._v("回答范例")])]),v._v(" "),e("ol",[e("li",[v._v("Vue中的diff算法称为patching算法，它由Snabbdom修改而来，虚拟DOM要想转化为真实DOM就需要通过\npatch方法转换。")]),v._v(" "),e("li",[v._v("最初Vue1.x视图中每个依赖均有更新函数对应，可以做到精准更新，因此并不需要虚拟DOM和patching算法支\n持，但是这样粒度过细导致Vue1.x无法承载较大应用；Vue 2.x中为了降低Watcher粒度，每个组件只有一个\nWatcher与之对应，此时就需要引入patching算法才能精确找到发生变化的地方并高效更新。")]),v._v(" "),e("li",[v._v("vue中diff执行的时刻是组件内响应式数据变更触发实例执行其更新函数时，更新函数会再次执行render函数获\n得最新的虚拟DOM，然后执行patch函数，并传入新旧两次虚拟DOM，通过比对两者找到变化的地方，最后将其\n转化为对应的DOM操作。")]),v._v(" "),e("li",[v._v("patch过程是一个递归过程，遵循深度优先、同层比较的策略；以vue3的patch为例：\n"),e("ul",[e("li",[v._v("首先判断两个节点是否为相同同类节点，不同则删除重新创建")]),v._v(" "),e("li",[v._v("如果双方都是文本则更新文本内容")]),v._v(" "),e("li",[v._v("如果双方都是元素节点则递归更新子元素，同时更新元素属性")]),v._v(" "),e("li",[v._v("更新子节点时又分了几种情况：\n"),e("ul",[e("li",[v._v("新的子节点是文本，老的子节点是数组则清空，并设置文本；")]),v._v(" "),e("li",[v._v("新的子节点是文本，老的子节点是文本则直接更新文本；")]),v._v(" "),e("li",[v._v("新的子节点是数组，老的子节点是文本则清空文本，并创建新子节点数组中的子元素；")]),v._v(" "),e("li",[v._v("新的子节点是数组，老的子节点也是数组，那么比较两组子节点，更新细节blabl")])])])])]),v._v(" "),e("li",[v._v("vue3中引入的更新策略：编译期优化patchFlags、block等")])]),v._v(" "),e("p",[e("strong",[v._v("知其所以然")])]),v._v(" "),e("p",[v._v("patch关键代码")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/runtime-core/src/renderer.ts#L354-L355")]),v._v(" "),e("h2",{attrs:{id:"_11-你知道哪些vue3新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-你知道哪些vue3新特性"}},[v._v("#")]),v._v(" 11 - 你知道哪些vue3新特性")]),v._v(" "),e("p",[e("strong",[v._v("分析")])]),v._v(" "),e("p",[v._v("Vue 3 中一些需要关注的新功能包括：")]),v._v(" "),e("ul",[e("li",[v._v("组合式 API")]),v._v(" "),e("li",[v._v("Teleport")]),v._v(" "),e("li",[v._v("片段")]),v._v(" "),e("li",[v._v("触发组件选项")]),v._v(" "),e("li",[v._v("来自 @vue/runtime-core 的 createRenderer API，用于创建自定义渲染器")]),v._v(" "),e("li",[v._v("单文件组件组合式 API 语法糖 (<script setup>)")]),v._v(" "),e("li",[v._v("单文件组件状态驱动的 CSS 变量 (<style> 中的 v-bind)")]),v._v(" "),e("li",[v._v("SFC <style scoped> 现在可以包含全局规则或只针对插槽内容的规则")]),v._v(" "),e("li",[v._v("Suspense")])]),v._v(" "),e("p",[e("strong",[v._v("回答范例")])]),v._v(" "),e("ol",[e("li",[v._v("api层面Vue3新特性主要包括：Composition API、SFC Composition API语法糖、Teleport传送⻔、\nFragments 片段、Emits选项、自定义渲染器、SFC CSS变量、Suspense")]),v._v(" "),e("li",[v._v("另外，Vue3.0在框架层面也有很多亮眼的改进：")])]),v._v(" "),e("ul",[e("li",[v._v("更快\n"),e("ul",[e("li",[v._v("虚拟DOM重写")]),v._v(" "),e("li",[v._v("编译器优化：静态提升、patchFlags、block等")]),v._v(" "),e("li",[v._v("基于Proxy的响应式系统")])])]),v._v(" "),e("li",[v._v("更小：更好的摇树优化")]),v._v(" "),e("li",[v._v("更容易维护：TypeScript + 模块化")]),v._v(" "),e("li",[v._v("更容易扩展\n"),e("ul",[e("li",[v._v("独立的响应化模块")]),v._v(" "),e("li",[v._v("自定义渲染器")])])])]),v._v(" "),e("p",[e("strong",[v._v("知其所以然")])]),v._v(" "),e("p",[v._v("体验编译器优化")]),v._v(" "),e("p",[v._v("https://sfc.vuejs.org/")]),v._v(" "),e("p",[v._v("reactive实现")]),v._v(" "),e("p",[v._v("https://github1s.com/vuejs/core/blob/HEAD/packages/reactivity/src/reactive.ts#L90-L91")])])}),[],!1,null,null,null);_.default=i.exports}}]);