(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{639:function(v,_,t){"use strict";t.r(_);var s=t(23),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"作用域-作用域链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域-作用域链"}},[v._v("#")]),v._v(" 作用域 & 作用域链")]),v._v(" "),t("h2",{attrs:{id:"作用域-scope"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域-scope"}},[v._v("#")]),v._v(" 作用域(scope)")]),v._v(" "),t("p",[v._v("防止不同范围的变量之间互相干扰 的 变量的可用范围")]),v._v(" "),t("h3",{attrs:{id:"全局作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域"}},[v._v("#")]),v._v(" 全局作用域")]),v._v(" "),t("p",[v._v("不属于任何函数的外部范围")]),v._v(" "),t("p",[v._v("保存在全局作用域的变量称为全局变量")]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("ul",[t("li",[v._v("优点: 可反复使用")]),v._v(" "),t("li",[v._v("缺点: 全局污染——开发时禁止使用")])]),v._v(" "),t("h3",{attrs:{id:"函数作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[v._v("#")]),v._v(" 函数作用域")]),v._v(" "),t("p",[v._v("一个函数内的范围称为函数作用域")]),v._v(" "),t("p",[v._v("保存在函数作用域内的变量称为局部变量")]),v._v(" "),t("blockquote",[t("p",[v._v("形参变量也是函数内的局部变量")])]),v._v(" "),t("p",[v._v("特点:")]),v._v(" "),t("ul",[t("li",[v._v("优点: 不会被污染")]),v._v(" "),t("li",[v._v("缺点: 无法反复使用")])]),v._v(" "),t("p",[t("strong",[v._v("强调: 只有函数的{}，才能形成作用域")])]),v._v(" "),t("p",[t("strong",[v._v("强调: JS中没有块级作用域")])]),v._v(" "),t("ul",[t("li",[v._v("除函数{}之外的其余{}，都不是作用域。")]),v._v(" "),t("li",[v._v("都拦不住内部的变量超出{}的范围影响外部程序")])]),v._v(" "),t("h2",{attrs:{id:"作用域链-scopes-scope-chain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域链-scopes-scope-chain"}},[v._v("#")]),v._v(" 作用域链 （scopes / scope chain）")]),v._v(" "),t("p",[v._v("每个函数在定义时，就已经规划好了自己专属的一个查找变量的路线图，称为作用域链")]),v._v(" "),t("p",[t("strong",[v._v("一个函数可用的所有作用域串联起来，就行成了当前函数的作用域链。")])]),v._v(" "),t("p",[v._v("Js中只有两种局部变量:")]),v._v(" "),t("ul",[t("li",[v._v("函数内"),t("strong",[v._v("var")]),v._v("出来的")]),v._v(" "),t("li",[v._v("函数的"),t("strong",[v._v("形参")]),v._v("变量")])]),v._v(" "),t("h2",{attrs:{id:"作用域的本质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域的本质"}},[v._v("#")]),v._v(" 作用域的本质")]),v._v(" "),t("p",[v._v("JS中，"),t("strong",[v._v("作用域和作用域链都是对象结构")])]),v._v(" "),t("ul",[t("li",[v._v("全局作用域其实是一个 window 的对象解构\n"),t("ul",[t("li",[v._v("所有全局变量和全局函数都是 window 对象的成员")])])]),v._v(" "),t("li",[v._v("对于还未调用函数作用域链上暂时只有一个作用域Global，既全局作用域对象window")])]),v._v(" "),t("p",[v._v("总结: "),t("strong",[v._v("函数作用域")])]),v._v(" "),t("p",[v._v("其实是js引擎在调用函数时才临时创建的一个作用域对象。其中保存函数的局部变量。而函数调用完，函数作用域对象就释放了。")]),v._v(" "),t("blockquote",[t("p",[v._v("JS中函数作用域对象，还有个别名——”活动的对象(Actived Object)”简称, AO。")])]),v._v(" "),t("h3",{attrs:{id:"函数调用过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数调用过程"}},[v._v("#")]),v._v(" 函数调用过程")]),v._v(" "),t("ul",[t("li",[v._v("创建函数保存局部变量")]),v._v(" "),t("li",[v._v("逐步执行")]),v._v(" "),t("li",[v._v("释放")])]),v._v(" "),t("h2",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[v._v("#")]),v._v(" 闭包")]),v._v(" "),t("p",[v._v("既重用变量又保护变量不被污染的一种编程方法。")]),v._v(" "),t("p",[v._v("只要希望给一个函数，保存一个即可反复使用，又不会被外界污染的专属局部变量时，就用闭包")]),v._v(" "),t("p",[t("strong",[v._v("强调:因为内层函数只是定义，未加()调用。所以，内层函数中的代码不执行！")])]),v._v(" "),t("p",[v._v("所有函数调用完只清空作用域链中离自己近的一个作用域")]),v._v(" "),t("p",[t("strong",[v._v("闭包就是每次调用外层函数时，临时创建的函数作用域对象")])]),v._v(" "),t("h3",{attrs:{id:"闭包如何形成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包如何形成"}},[v._v("#")]),v._v(" 闭包如何形成")]),v._v(" "),t("p",[t("strong",[v._v("外层函数调用后，外层函数的作用域对象，被返回的内层函数的作用域链引用着，无法释放，就形成了闭包对象")])]),v._v(" "),t("h3",{attrs:{id:"闭包缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包缺点"}},[v._v("#")]),v._v(" 闭包缺点")]),v._v(" "),t("p",[v._v("极容易"),t("strong",[v._v("造成内存泄漏")])]),v._v(" "),t("p",[v._v("如何释放不用的闭包对象？将保存内层函数对象的变量赋值为null")])])}),[],!1,null,null,null);_.default=a.exports}}]);